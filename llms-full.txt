# Universal Commerce Protocol (UCP)

> The Universal Commerce Protocol (UCP) is a solution for enabling gen AI agents to make payments on behalf of users, safely, securely, and in a decentralized and privacy protecting manner. This protocol is a part of the broader ecosystem, which includes agentic protocols like A2A and MCP, and encompasses the global nature of payments.


# Overview

# Universal Commerce Protocol

The common language for platforms, agents and businesses.

UCP defines building blocks for agentic commerce—from discovering and buying to post purchase experiences—allowing the ecosystem to interoperate through one standard, without custom builds.

### Learn

Protocol overview, core concepts, and design principles

[Read the docs](https://ucp.dev/specification/overview/index.md)

### Implement

GitHub repo, technical spec, SDKs, and reference implementations

[View on GitHub](https://github.com/Universal-Commerce-Protocol/ucp)

## Co-developed and adopted by industry leaders

UCP was built by the industry, for the industry to solve for fragmented commerce journeys that lead to abandoned carts and frustrated shoppers, and enable agentic commerce.

Google

Shopify

Etsy

Wayfair

Target

Walmart

## Built for flexibility, security, and scale

Agentic commerce demands interoperability. UCP is built on industry standards — REST and JSON-RPC transports; [Agent Payments Protocol (AP2)](https://ap2-protocol.org/), [Agent2Agent (A2A)](https://a2a-protocol.org/latest/), and [Model Context Protocol (MCP)](https://modelcontextprotocol.io/docs/getting-started/intro) support built-in — so different systems can work together without custom integration.

### Scalable and universal

Surface-agnostic design that can scale to support any commerce entity (from small businesses to enterprise scale) and all modalities (chat, visual commerce, voice, etc).

### Businesses at the center

Built to facilitate commerce, ensuring retailers retain control of their business rules and remain the Merchant of Record with full ownership of the customer relationship.

### Open and extensible

Open and extensible by design, enabling development of community-driven capabilities and extensions across verticals.

### Secure and private

Built on proven security standards for account linking (OAuth 2.0) and secure payment (AP2) via payment mandates and verifiable credentials.

### Frictionless payments

Open wallet ecosystem with interoperability between providers to ensure buyers can pay with their preferred payment methods.

## See it in action

UCP is designed to facilitate the entire commerce lifecycle, from initial product discovery and search to final sale and post-purchase support. The protocol's initial launch focuses on three core capabilities: Checkout, Identity Linking, and Order Management.

Checkout Identity Linking Order

SEE IT IN ACTION

### Checkout

Support complex cart logic, dynamic pricing, tax calculations, and more across millions of businesses through unified checkout sessions.

[Learn more](https://ucp.dev/specification/checkout-rest/index.md)

```json
{
  "ucp": { ... },
  "id": "chk_123456789",
  "status": "ready_for_complete",
  "currency": "USD",
  "buyer": {
    "email": "e.beckett@example.com",
    "first_name": "Elisa",
    "last_name": "Beckett"
  },
  "line_items": [
    {
      "id": "li_1",
      "item": {
        "id": "item_123",
        "title": "Monos Carry-On Pro suitcase",
        "price": 26550
      },
      "quantity": 1,
      ...
    }
  ],
  "totals": [ ... ],
  "links": [ ... ],
  "payment": { ... },
  "fulfillment": {
    "methods": [
      {
        "id": "method_1",
        "type": "shipping",
        "line_item_ids": ["li_1"],
        "selected_destination_id": "dest_1",
        "destinations": [
          {
            "id": "dest_1",
            "first_name": "Elisa",
            "last_name": "Beckett",
            "street_address": "1600 Amphitheatre Pkwy",
            "address_locality": "Mountain View",
            "address_region": "CA",
            "postal_code": "94043",
            "address_country": "US"
          }
        ],
        "groups": [
          {
            "id": "group_1",
            "line_item_ids": ["li_1"],
            "selected_option_id": "free-shipping",
            "options": [
              {
                "id": "free-shipping",
                "title": "Free Shipping",
                "totals": [ {"type": "total", "amount": 0} ]
              }
            ]
          }
        ]
      }
    ]
  }
}
```

SEE IT IN ACTION

### Identity Linking

OAuth 2.0 standard enables agents to maintain secure, authorized relationships without sharing credentials.

[Learn more](https://ucp.dev/specification/identity-linking/index.md)

```json
Sample of /.well-known/oauth-authorization-server

{
  "issuer": "https://example.com",
  "authorization_endpoint": "https://example.com/oauth2/authorize",
  "token_endpoint": "https://example.com/oauth2/token",
  "revocation_endpoint": "https://example.com/oauth2/revoke",
  "scopes_supported": [
    "ucp:scopes:checkout_session",
  ],
  "response_types_supported": [
    "code"
  ],
  "grant_types_supported": [
    "authorization_code",
    "refresh_token"
  ],
  "token_endpoint_auth_methods_supported": [
    "client_secret_basic"
  ],
  "service_documentation": "https://example.com/docs/oauth2"
}
```

SEE IT IN ACTION

### Order

From purchase confirmation to delivery. Real-time webhooks power status updates, shipment tracking, and return processing across every channel.

[Learn more](https://ucp.dev/specification/order/index.md)

```json
{
  "ucp": { ... },
  "id": "order_123456789",
  "checkout_id": "chk_123456789",
  "permalink_url": ...,
  "line_items": [ ... ],
  "fulfillment": {
    "expectations": [
      {
        "id": "exp_1",
        "line_items": [{ "id": "li_1", "quantity": 1 }],
        "method_type": "shipping",
        "destination": {
          "first_name": "Elisa",
          "last_name": "Beckett",
          "street_address": "1600 Amphitheatre Pkwy",
          "address_locality": "Mountain View",
          "address_region": "CA",
          "postal_code": "94043",
          "address_country": "US"
        },
        "description": "Arrives in 2-3 business days",
        "fulfillable_on": "now"
      }
      ...
    ],
    "events": [
      {
        "id": "evt_1",
        "occurred_at": "2026-01-11T10:30:00Z",
        "type": "delivered",
        "line_items": [{ "id": "li_1", "quantity": 1 }],
        "tracking_number": "123456789",
        "tracking_url": "https://fedex.com/track/123456789",
        "description": "Delivered to front door"
      }
    ]
  },
  "adjustments": [
    {
      "id": "adj_1",
      "type": "refund",
      "occurred_at": "2026-01-12T14:30:00Z",
      "status": "completed",
      "line_items": [{ "id": "li_1", "quantity": 1 }],
      "amount": 26550,
      "description": "Defective item"
    }
  ],
  "totals": [ ... ]
}
```

### Power native checkout

Integrate and negotiate directly with a seller's checkout API to power native UI and workflows for your platform.

[See how it works](https://ucp.dev/specification/checkout-rest/index.md)

### Embed business checkout

Embed and render business checkout UI to support complex checkout flows, with advanced capabilities like bidirectional communication, and payment and shipping address delegation.

[Learn more](https://ucp.dev/specification/embedded-checkout/index.md)

## Designed for the entire commerce ecosystem

### For Developers

Build the future of commerce on an open foundation. Join our community in evolving an open-source standard designed for the next generation of digital commerce.

[View the technical spec](https://ucp.dev/specification/overview/index.md)

### For Businesses

UCP empowers retailers to meet customers wherever they are—AI assistants, shopping agents, embedded experiences—without rebuilding your checkout for each. You remain the Merchant of Record and your business logic stays intact.

[Integrate with UCP](https://developers.google.com/merchant/ucp/)

### For AI Platforms

Simplify business onboarding with standardized APIs and provide your audience with an integrated shopping experience. Compatible with MCP, A2A, and existing agent frameworks.

[Learn more about UCP core concepts](https://ucp.dev/documentation/core-concepts/index.md)

### For Payment Providers

Universal payments that are provable—every authorization backed by cryptographic proof of user consent. Open, modular payment handler design enables open interoperability and choice of payment methods.

[Learn more about UCP and AP2](https://ucp.dev/documentation/ucp-and-ap2/index.md)

## Endorsed across the ecosystem

Adyen

Affirm

Amex

Ant International

Best Buy

Block

Carrefour

Chewy

Commerce

Fiserv

Flipkart

Gap

Klarna

Kroger

Lowe's

Macy's

Mastercard

Paypal

Salesforce

Sephora

Shopee

Splitit

Stripe

The Home Depot

Ulta

Visa

Worldpay

Zalando

Adyen

Affirm

Amex

Ant International

Best Buy

Block

Carrefour

Chewy

Commerce

Fiserv

Flipkart

Gap

Klarna

Kroger

Lowe's

Macy's

Mastercard

Paypal

Salesforce

Sephora

Shopee

Splitit

Stripe

The Home Depot

Ulta

Visa

Worldpay

Zalando

## Get started today

UCP is an open standard designed to let AI agents, apps, businesses, and payment providers interact seamlessly without needing custom, one-off integrations for every connection. We actively seek your feedback and contributions to help build the future of commerce.

The complete technical specification, documentation, and reference implementations are hosted in our public GitHub repository.

### [Download](https://github.com/Universal-Commerce-Protocol/samples)

Download and run our code samples

### [Experiment](https://ucp.dev/playground/)

Experiment with the protocol and its different agent roles

### [Contribute](https://github.com/Universal-Commerce-Protocol/ucp/blob/main/CONTRIBUTING.md)

Contribute your feedback and code to the public repository

[Visit the GitHub repository](https://github.com/Universal-Commerce-Protocol/ucp)

# Core Concepts

The Universal Commerce Protocol (UCP) is an open standard designed to facilitate communication and interoperability between diverse commerce entities. In a fragmented landscape where consumer surfaces/platforms, businesses, payment providers, and identity providers operate on different systems, UCP provides a standardized common language and functional primitives.

This document provides the detailed technical specification for UCP. For a complete definition of all data models and schemas, see the [Schema Reference](/ucp/latest/specification/reference.md).

Its primary goal is to enable:

- **Consumer Surfaces/Platforms:** To discover business capabilities and facilitate purchases.
- **Businesses:** To expose their inventory and retail logic in a standard way without building custom integrations for every platform.
- **Payment & Credential Providers:** To securely exchange tokens and credentials to facilitate transactions.

## High level architecture

## Key Goals of UCP

- **Interoperability:** Bridge the gap between consumer surfaces, businesses, and payment ecosystems.
- **Discovery:** Allow consumer surfaces to dynamically discover what businesses support (e.g., "Do they support guest checkout?", "Do they have loyalty programs?").
- **Security:** Facilitate secure, standards-based (OAuth 2.0, PCI-DSS compliant patterns) exchanges of sensitive user and payment data.
- **Agentic Commerce:** Enable AI agents to act on behalf of users to complete complex tasks like "Find a headset under $100 and buy it."

## Roles & Participants

UCP defines the interactions between four primary distinct actors, each playing a specific role in the commerce lifecycle.

### Platform (Application/Agent)

The platform is the consumer-facing surface (such as an AI agent, mobile app, or social media site) acting on behalf of the User. It orchestrates the commerce journey by discovering businesses and facilitating user intent.

- **Responsibilities:** Discovering businesses capabilities via profiles, initiating checkout sessions, and presenting the UI or conversational interface to the user.
- **Examples:** AI Shopping Assistants, Super Apps, Search Engines.

### Business

The entity selling goods or services. In the UCP model, businesses act as the **Merchant of Record (MoR)**, retaining financial liability and ownership of the order.

- **Responsibilities:** Exposing commerce capabilities (inventory, pricing, tax calculation), fulfilling orders, and processing payments via their chosen PSP.
- **Examples:** Retailers, Airlines, Hotel Chains, Service Providers.

### Credential Provider (CP)

A trusted entity responsible for securely managing and sharing sensitive user data, particularly payment instruments and shipping addresses.

- **Responsibilities:** Authenticating the user, issuing payment tokens (to keep raw card data off the platform), and holding PII securely to minimize compliance scope for other parties.
- **Examples:** Digital Wallets (e.g., Google Wallet, Apple Pay), Identity Providers.

### Payment Service Provider (PSP)

The financial infrastructure provider that processes payments on behalf of businesses.

- **Responsibilities:** Authorizing and capturing transactions, handling settlements, and communicating with card networks. The PSP often interacts directly with tokens provided by the Credential Provider.
- **Examples:** Stripe, Adyen, PayPal, Braintree, Chase Paymentech.

## Core Concepts Summary

UCP revolves around three fundamental constructs that define how entities interact.

- **Capabilities:** Standalone core features that a business supports. These are the "verbs" of the protocol.
  - *Examples:* Checkout, Identity Linking, Order.
- **Extensions:** Optional capabilities that augment another capability via the `extends` field. Extensions appear in `ucp.capabilities[]` alongside core capabilities.
  - *Examples:* Discounts (extends Checkout), AP2 Mandates (extends Checkout).
- **Services:** The lower-level communication layers used to exchange data. UCP is transport-agnostic but defines specific bindings for interoperability.
  - *Examples:* REST API (primary), MCP (Model Context Protocol), A2A (Agent2Agent).

# UCP and AP2

UCP is fully compatible with [Agent Payments Protocol (AP2)](https://ap2-protocol.org/). AP2 serves as the trust layer for agent-led transactions completed on behalf of a user, mandating a secure, verifiable exchange of intents and authorizations between Platforms and businesses. By using Verifiable Digital Credentials (VDCs), AP2 eliminates the need for middleman "trust referees." It allows businesses to receive signed checkout commitments—ensuring the price and terms don't change mid-flow—and allows Platforms to provide cryptographically signed payment authorizations that are mathematically tied to the specific state of the cart.

## Key benefits

- **Binding proof:** Both parties have cryptographic evidence of exactly what was offered and what was agreed upon, ensuring the transaction is final and authentic.
- **Fraud reduction:** Payment mandates are scoped specifically to a checkout hash, preventing "token replay" or amount manipulation.
- **Agentic readiness:** Allows autonomous AI agents to transact on behalf of users with pre-defined, verifiable boundaries.

## Protocol flow

1. **Discovery:** The business publishes their discovery document, declaring support for the AP2 extension.
1. **Session Activation:** When creating or updating a checkout session, the Platform signals the activation of AP2.
1. **Signing (business):** The business responds with a `checkoutSignature` (a detached JWT signing the checkout state) and lists supported verifiable presentation formats (e.g., `sd-jwt`).
1. **Authorization:** Upon user consent, the Platform generates two credentials:
   - **CheckoutMandate:** Contains the hash of the `CheckoutObject`.
   - **PaymentMandate:** An SD-JWT-VC containing the payment authorization.
1. **Completion:** The Platform submits both mandates to the business’ `/complete` endpoint.
1. **Verification:**
   - The business verifies the `CheckoutMandate`.
   - The Payment Processor verifies the `PaymentMandate`.
1. **Confirmation:** If valid, the payment is processed, and the order is confirmed.

**Dependencies:** Checkout capability

[See here for full AP2 mandates extension](/ucp/latest/specification/ap2-mandates.md)

[Learn more about AP2](https://ap2-protocol.org)

# Roadmap

This roadmap is meant to provide transparency into our strategic priorities and to align our partners on the critical path toward a fully agentic, global commerce standard. Our goal is to move beyond isolated transactions and build a cohesive, intelligent commerce layer that works across borders and verticals.

**Note:** This roadmap reflects our current direction and intends to guide planning, but it does not constitute a commitment to deliver specific features. Our approach to these challenges may evolve, and initiatives are subject to change, removal, or addition as business priorities shift and we receive community feedback.

## Upcoming roadmap priorities

### Deeper support for the full consumer journey

To move beyond isolated transactions, we are expanding the protocol's scope to tackle key user journeys such as multi-item checkout, loyalty, and lifecycle management, while ensuring the business's brand and logic remain central to all shopping experiences. Key upcoming initiatives include:

- **Product discovery and post-order management:** By facilitating the entire journey, we help businesses maximize lifetime and average order value rather than just processing a single item for checkout.
- **Cart and basket building:** Support for multi-item checkout from a business, complex basket rules (e.g., promotions, tax, shipping), and varied fulfillment logic that reflects how people actually shop.
- **Loyalty & Member benefits:** Capabilities to enable loyalty and member benefits to help users find the best value and businesses achieve a deeper connection with their consumers through account linking.
- **Native cross-sell and upsell modules:** Capabilities for businesses to provide personalized recommendations and upsells based on user context.

### Support for global markets

We are building a scalable ecosystem that is inclusive of all business sizes and geographies, ensuring that "simple and open" means accessible to everyone. We plan to do this through a phased rollout across markets, including India, Indonesia, Latin America, and others. We are adapting the protocol to support broader regional use cases and localized payment interoperability.

## Build with us

The future of commerce cannot be built in a vacuum. We invite businesses, developers, and payment providers to join us in refining these specifications. Your feedback on our early builds helps us shape the standards that will power the next generation of global commerce.

[Become a UCP contributor](https://github.com/Universal-Commerce-Protocol/ucp?tab=contributing-ov-file)

# Schema Authoring Guide

This guide documents conventions for authoring UCP JSON schemas: metadata fields, the registry pattern, schema variants, and versioning.

## Schema Metadata Fields

UCP schemas use standard JSON Schema fields plus UCP-specific metadata:

| Field         | Standard    | Purpose                                                             | Required For                             |
| ------------- | ----------- | ------------------------------------------------------------------- | ---------------------------------------- |
| `$schema`     | JSON Schema | Declares JSON Schema draft version (**SHOULD** use `draft/2020-12`) | All schemas                              |
| `$id`         | JSON Schema | Schema's canonical URI for `$ref` resolution                        | All schemas                              |
| `title`       | JSON Schema | Human-readable display name                                         | All schemas                              |
| `description` | JSON Schema | Schema purpose and usage                                            | All schemas                              |
| `name`        | UCP         | Reverse-domain identifier; doubles as registry key                  | Capabilities, services, handlers         |
| `version`     | UCP         | Entity version (`YYYY-MM-DD` format)                                | Capabilities, services, payment handlers |
| `id`          | UCP         | Instance identifier for multiple configurations                     | Payment handlers only                    |

### Why Self-Describing?

Capability schemas **must be self-describing**: when a platform fetches a schema, it should determine exactly what capability and version it represents without cross-referencing other documents. This matters because:

1. **Independent versioning**: Capabilities may version independently. The schema must declare its version explicitly—you can't infer it from the URL.
1. **Validation**: Validators can cross-check that a capability declaration's `schema` URL points to a schema whose embedded `name`/`version` match the declaration. Mismatches are authoring errors caught at build time.
1. **Developer experience**: When reading a schema file, integrators immediately see what capability it defines without reverse-engineering the `$id` URL.
1. **Compact namespace**: The `name` field provides a standardized reverse-domain identifier (e.g., `dev.ucp.shopping.checkout`) that's more compact and semantic than the full `$id` URL.

### Why Both `$id` and `name`?

| Field  | Role                                                    | Format                 |
| ------ | ------------------------------------------------------- | ---------------------- |
| `$id`  | JSON Schema primitive for `$ref` resolution and tooling | URI (required by spec) |
| `name` | Registry key and stable identifier                      | Reverse-domain         |

`$id` must be a valid URI per JSON Schema spec. `name` is the **key used in registries** (`capabilities`, `services`, `payment_handlers`) and the wire protocol identifier used in capability negotiation—decoupled from schema hosting so that `schema` URLs can change as infrastructure evolves.

The reverse-domain format provides **namespace governance**: domain owners control their namespace (`dev.ucp.*`, `com.shopify.*`), avoiding collisions between UCP and vendor entities. This stable identity layer allows trust and resolution mechanisms to evolve independently—future versions could adopt verifiable credentials, content-addressed schemas, or other verification methods without breaking capability negotiation.

### Why `version` Uses Dates?

The `version` field uses date-based versioning (`YYYY-MM-DD`) to enable:

- **Capability negotiation**: Platforms request specific versions they support
- **Breaking change management**: New versions get new dates; old versions remain valid and resolvable
- **Independent lifecycles**: Extensions can release on their own schedule

## Schema Categories

UCP schemas fall into six categories based on their role in the protocol.

### Capability Schemas

Define negotiated capabilities that appear in `ucp.capabilities{}` registries.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`, `name`, `version`
- **Variants**: `platform_schema`, `business_schema`, `response_schema`

Examples: `checkout.json`, `fulfillment.json`, `discount.json`, `order.json`

### Service Schemas

Define transport bindings that appear in `ucp.services{}` registries. Each transport (REST, MCP, A2A, Embedded) is a separate entry.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`, `name`, `version`
- **Variants**: `platform_schema`, `business_schema`
- **Transport requirements**:
  - REST/MCP: `endpoint`, `schema` (OpenAPI/OpenRPC URL)
  - A2A: `endpoint` (Agent Card URL)
  - Embedded: `schema` (OpenRPC URL)

### Payment Handler Schemas

Define payment handler configurations in `ucp.payment_handlers{}` registries.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`, `name`, `version`
- **Variants**: `platform_schema`, `business_schema`, `response_schema`
- **Instance `id`**: Required to distinguish multiple configurations of the same handler

Examples: `com.google.pay`, `dev.shopify.shop_pay`, `dev.ucp.processor_tokenizer`

**→ See [Payment Handler Guide](/ucp/latest/specification/payment-handler-guide.md)** for detailed guidance on handler structure, config/instrument/credential schemas, and the full specification template.

### Component Schemas

Data structures embedded within capabilities but not independently negotiated. Do **not** appear in registries.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`
- **Omit**: `name`, `version` (not independently versioned)

Examples:

- `schemas/shopping/payment.json` — Payment configuration (part of checkout)

### Type Schemas

Reusable definitions referenced by other schemas. Do **not** appear in registries.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`
- **Omit**: `name`, `version`

Examples: `types/buyer.json`, `types/line_item.json`, `types/postal_address.json`

### Meta Schemas

Define protocol structure rather than entity payloads.

- **Top-level fields**: `$schema`, `$id`, `title`, `description`
- **Omit**: `name`, `version`

Examples: `ucp.json` (entity base), `capability.json`, `service.json`, `payment_handler.json`

## The Registry Pattern

UCP organizes capabilities, services, and handlers in **registries**—objects keyed by `name` rather than arrays of objects with `name` fields.

```json
{
  "capabilities": {
    "dev.ucp.shopping.checkout": [{"version": "2026-01-11"}],
    "dev.ucp.shopping.fulfillment": [{"version": "2026-01-11"}]
  },
  "services": {
    "dev.ucp.shopping": [
      {"version": "2026-01-11", "transport": "rest"},
      {"version": "2026-01-11", "transport": "mcp"}
    ]
  },
  "payment_handlers": {
    "com.google.pay": [{"id": "gpay_1234", "version": "2026-01-11"}]
  }
}
```

### Registry Contexts

The same registry structure appears in three contexts with different field requirements:

| Context          | Location                | Required Fields                 |
| ---------------- | ----------------------- | ------------------------------- |
| Platform Profile | Advertised URI          | `version`, `spec`, `schema`     |
| Business Profile | `/.well-known/ucp`      | `version`; may add `config`     |
| API Responses    | Checkout/order payloads | `version` (+ `id` for handlers) |

## The Entity Pattern

All capabilities, services, and handlers extend a common `entity` base schema:

| Field     | Type   | Description                                     |
| --------- | ------ | ----------------------------------------------- |
| `version` | string | Entity version (`YYYY-MM-DD`) — always required |
| `spec`    | URI    | Human-readable specification                    |
| `schema`  | URI    | JSON Schema URL                                 |
| `id`      | string | Instance identifier (handlers only)             |
| `config`  | object | Entity-specific configuration                   |

### Schema Variants

Each entity type defines **three variants** for different contexts:

**`platform_schema`** — Full declarations for discovery

```json
{
  "dev.ucp.shopping.fulfillment": [{
    "version": "2026-01-11",
    "spec": "https://ucp.dev/specification/fulfillment",
    "schema": "https://ucp.dev/schemas/shopping/fulfillment.json",
    "config": {
      "supports_multi_group": true
    }
  }]
}
```

**`business_schema`** — Business-specific overrides

```json
{
  "dev.ucp.shopping.fulfillment": [{
    "version": "2026-01-11",
    "config": {
      "allows_multi_destination": {"shipping": true}
    }
  }]
}
```

**`response_schema`** — Minimal references in API responses

```json
{
  "ucp": {
    "capabilities": {
      "dev.ucp.shopping.fulfillment": [{"version": "2026-01-11"}]
    }
  }
}
```

Define all three in your schema's `$defs`:

```json
"$defs": {
  "platform_schema": {
    "allOf": [{"$ref": "../capability.json#/$defs/platform_schema"}]
  },
  "business_schema": {
    "allOf": [{"$ref": "../capability.json#/$defs/business_schema"}]
  },
  "response_schema": {
    "allOf": [{"$ref": "../capability.json#/$defs/response_schema"}]
  }
}
```

## Versioning Strategy

### UCP Capabilities (`dev.ucp.*`)

UCP-authored capabilities version with protocol releases by default. Individual capabilities **may** version independently when needed.

### Vendor Capabilities (`com.{vendor}.*`)

Capabilities outside `dev.ucp.*` version fully independently:

```json
{
  "name": "com.shopify.loyalty",
  "version": "2025-09-01",
  "spec": "https://shopify.dev/ucp/loyalty",
  "schema": "https://shopify.dev/ucp/schemas/loyalty.json"
}
```

Vendor schemas follow the same self-describing requirements.

## Complete Example: Capability Schema

A capability schema defines both payload structure and declaration variants:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://ucp.dev/schemas/shopping/checkout.json",
  "name": "dev.ucp.shopping.checkout",
  "version": "2026-01-11",
  "title": "Checkout",
  "description": "Base checkout schema. Extensions compose via allOf.",

  "$defs": {
    "platform_schema": {
      "allOf": [{"$ref": "../capability.json#/$defs/platform_schema"}]
    },
    "business_schema": {
      "allOf": [{"$ref": "../capability.json#/$defs/business_schema"}]
    },
    "response_schema": {
      "allOf": [{"$ref": "../capability.json#/$defs/response_schema"}]
    }
  },

  "type": "object",
  "required": ["ucp", "id", "line_items", "status", "currency", "totals", "links"],
  "properties": {
    "ucp": {"$ref": "../ucp.json#/$defs/response_checkout_schema"},
    "id": {"type": "string", "description": "Checkout identifier"},
    "line_items": {"type": "array", "items": {"$ref": "types/line_item.json"}},
    "status": {"type": "string", "enum": ["open", "completed", "expired"]},
    "currency": {"type": "string", "pattern": "^[A-Z]{3}$"},
    "totals": {"$ref": "types/totals.json"},
    "links": {"$ref": "types/links.json"}
  }
}
```

Key points:

- **Top-level `name` and `version`** make the schema self-describing
- **`$defs` variants** enable validation in different contexts
- **Payload properties** define the actual checkout response structure

# Versioning

UCP uses date-based version identifiers following the format YYYY-MM-DD, to indicate the last date backwards incompatible changes were made.

New development occurs on the `main` branch. We will maintain long-lived branches for all supported releases of the spec.

- When the Tech Council approves a new version of UCP, we will cut a new branch named `release/YYYY-MM-DD` directly from the current state of `main`.
  - We will implement a code freeze on the release branch the moment a `release/YYYY-MM-DD branch` is cut. Only critical bug fixes should move during this window.
  - Critical issues discovered after cutting a release branch should be fixed in one of two ways:
  - The fix is made on the release branch and merged to `main`.
  - The fix is made on `main` and cherry-picked to the release branch.
- Once finalized, we will merge the release branch into `main` and tag it (e.g. `git tag -a vYYYY-MM-DD`). We will use a GitHub Action to detect the new Tag and automatically generate a release notes draft and upload artifacts.
- Unlike temporary feature branches, release/YYYY-MM-DD branches are long-lived and correspond to specific versions of the spec for historical reference and maintenance.

## Breaking PRs

- Breaking changes should include `!` in the PR title
- Timing: We will announce the breaking change in Discussions 2 weeks before the change is merged.
