/* tslint:disable:enforce-comments-on-exported-symbols */
/* eslint-disable */
/* tslint:disable:enforce-name-casing */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * JWS Detached Content signature (RFC 7515 Appendix F) over the checkout response body (excluding ap2 field). Format: `<base64url-header>..<base64url-signature>`. The header MUST contain 'alg' (ES256/ES384/ES512) and 'kid' claims. The signature covers both the header and JCS-canonicalized checkout payload.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "merchant_authorization".
 */
export type MerchantAuthorizationCompleteRequest = string;
/**
 * SD-JWT+kb credential in `ap2.checkout_mandate`. Proving user authorization for the checkout. Contains the full checkout including `ap2.merchant_authorization`.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "checkout_mandate".
 */
export type CheckoutMandateCompleteRequest = string;
/**
 * Checkout extended with AP2 mandate support.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithAP2MandateCompleteRequest = CheckoutCompleteRequest & {
  ap2?: Ap2WithMerchantAuthorization & Ap2WithCheckoutMandate;
  [k: string]: unknown;
};
/**
 * Matches a specific instrument type based on validation logic.
 */
export type PaymentInstrument = CardPaymentInstrument;
/**
 * A basic card payment instrument with visible card details. Can be inherited by a handler's instrument schema to define handler-specific display details or more complex credential structures.
 */
export type CardPaymentInstrument = PaymentInstrumentBase & {
  /**
   * Indicates this is a card payment instrument.
   */
  type: 'card';
  /**
   * The card brand/network (e.g., visa, mastercard, amex).
   */
  brand: string;
  /**
   * Last 4 digits of the card number.
   */
  last_digits: string;
  /**
   * The month of the card's expiration date (1-12).
   */
  expiry_month?: number;
  /**
   * The year of the card's expiration date.
   */
  expiry_year?: number;
  /**
   * An optional rich text description of the card to display to the user (e.g., 'Visa ending in 1234, expires 12/2025').
   */
  rich_text_description?: string;
  /**
   * An optional URI to a rich image representing the card (e.g., card art provided by the issuer).
   */
  rich_card_art?: string;
  [k: string]: unknown;
};
/**
 * Container for sensitive payment data. Use the specific schema matching the 'type' field.
 */
export type PaymentCredential = TokenCredentialResponse | CardCredential;
/**
 * Error codes specific to AP2 mandate verification.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "error_code".
 */
export type AP2ErrorCodeCompleteRequest =
  | 'mandate_required'
  | 'agent_missing_key'
  | 'mandate_invalid_signature'
  | 'mandate_expired'
  | 'mandate_scope_mismatch'
  | 'merchant_authorization_invalid'
  | 'merchant_authorization_missing';
/**
 * JWS Detached Content signature (RFC 7515 Appendix F) over the checkout response body (excluding ap2 field). Format: `<base64url-header>..<base64url-signature>`. The header MUST contain 'alg' (ES256/ES384/ES512) and 'kid' claims. The signature covers both the header and JCS-canonicalized checkout payload.
 *
 * This interface was referenced by `AP2MandateExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "merchant_authorization".
 */
export type MerchantAuthorizationCreateRequest = string;
/**
 * SD-JWT+kb credential in `ap2.checkout_mandate`. Proving user authorization for the checkout. Contains the full checkout including `ap2.merchant_authorization`.
 *
 * This interface was referenced by `AP2MandateExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "checkout_mandate".
 */
export type CheckoutMandateCreateRequest = string;
/**
 * Checkout extended with AP2 mandate support.
 *
 * This interface was referenced by `AP2MandateExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithAP2MandateCreateRequest = CheckoutCreateRequest & {
  [k: string]: unknown;
};
/**
 * Error codes specific to AP2 mandate verification.
 *
 * This interface was referenced by `AP2MandateExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "error_code".
 */
export type AP2ErrorCodeCreateRequest =
  | 'mandate_required'
  | 'agent_missing_key'
  | 'mandate_invalid_signature'
  | 'mandate_expired'
  | 'mandate_scope_mismatch'
  | 'merchant_authorization_invalid'
  | 'merchant_authorization_missing';
/**
 * JWS Detached Content signature (RFC 7515 Appendix F) over the checkout response body (excluding ap2 field). Format: `<base64url-header>..<base64url-signature>`. The header MUST contain 'alg' (ES256/ES384/ES512) and 'kid' claims. The signature covers both the header and JCS-canonicalized checkout payload.
 *
 * This interface was referenced by `AP2MandateExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "merchant_authorization".
 */
export type MerchantAuthorizationUpdateRequest = string;
/**
 * SD-JWT+kb credential in `ap2.checkout_mandate`. Proving user authorization for the checkout. Contains the full checkout including `ap2.merchant_authorization`.
 *
 * This interface was referenced by `AP2MandateExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "checkout_mandate".
 */
export type CheckoutMandateUpdateRequest = string;
/**
 * Checkout extended with AP2 mandate support.
 *
 * This interface was referenced by `AP2MandateExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithAP2MandateUpdateRequest = CheckoutUpdateRequest & {
  [k: string]: unknown;
};
/**
 * Error codes specific to AP2 mandate verification.
 *
 * This interface was referenced by `AP2MandateExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "error_code".
 */
export type AP2ErrorCodeUpdateRequest =
  | 'mandate_required'
  | 'agent_missing_key'
  | 'mandate_invalid_signature'
  | 'mandate_expired'
  | 'mandate_scope_mismatch'
  | 'merchant_authorization_invalid'
  | 'merchant_authorization_missing';
/**
 * JWS Detached Content signature (RFC 7515 Appendix F) over the checkout response body (excluding ap2 field). Format: `<base64url-header>..<base64url-signature>`. The header MUST contain 'alg' (ES256/ES384/ES512) and 'kid' claims. The signature covers both the header and JCS-canonicalized checkout payload.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "merchant_authorization".
 */
export type MerchantAuthorizationResponse = string;
/**
 * SD-JWT+kb credential in `ap2.checkout_mandate`. Proving user authorization for the checkout. Contains the full checkout including `ap2.merchant_authorization`.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "checkout_mandate".
 */
export type CheckoutMandateResponse = string;
/**
 * Checkout extended with AP2 mandate support.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithAP2MandateResponse = CheckoutResponse & {
  ap2?: Ap2WithMerchantAuthorization1 & Ap2WithCheckoutMandate1;
  [k: string]: unknown;
};
/**
 * Capability reference in responses. Only name/version required to confirm active capabilities.
 */
export type CapabilityResponse = Base & {
  [k: string]: unknown;
};
/**
 * Container for error, warning, or info messages.
 */
export type Message = MessageError | MessageWarning | MessageInfo;
/**
 * Error codes specific to AP2 mandate verification.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "error_code".
 */
export type AP2ErrorCodeResponse =
  | 'mandate_required'
  | 'agent_missing_key'
  | 'mandate_invalid_signature'
  | 'mandate_expired'
  | 'mandate_scope_mismatch'
  | 'merchant_authorization_invalid'
  | 'merchant_authorization_missing';
/**
 * Buyer object extended with consent tracking.
 *
 * This interface was referenced by `BuyerConsentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "buyer".
 */
export type BuyerWithConsentCompleteRequest = Buyer & {
  consent?: Consent;
  [k: string]: unknown;
};
/**
 * Checkout extended with consent tracking via buyer object.
 *
 * This interface was referenced by `BuyerConsentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithBuyerConsentCompleteRequest = CheckoutCompleteRequest & {
  [k: string]: unknown;
};
/**
 * Buyer object extended with consent tracking.
 *
 * This interface was referenced by `BuyerConsentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "buyer".
 */
export type BuyerWithConsentCreateRequest = Buyer & {
  consent?: Consent1;
  [k: string]: unknown;
};
/**
 * Checkout extended with consent tracking via buyer object.
 *
 * This interface was referenced by `BuyerConsentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithBuyerConsentCreateRequest = CheckoutCreateRequest & {
  buyer?: BuyerWithConsentCreateRequest;
  [k: string]: unknown;
};
/**
 * Buyer object extended with consent tracking.
 *
 * This interface was referenced by `BuyerConsentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "buyer".
 */
export type BuyerWithConsentUpdateRequest = Buyer & {
  consent?: Consent2;
  [k: string]: unknown;
};
/**
 * Checkout extended with consent tracking via buyer object.
 *
 * This interface was referenced by `BuyerConsentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithBuyerConsentUpdateRequest = CheckoutUpdateRequest & {
  buyer?: BuyerWithConsentUpdateRequest;
  [k: string]: unknown;
};
/**
 * Buyer object extended with consent tracking.
 *
 * This interface was referenced by `BuyerConsentExtensionResponse`'s JSON-Schema
 * via the `definition` "buyer".
 */
export type BuyerWithConsentResponse = Buyer & {
  consent?: Consent3;
  [k: string]: unknown;
};
/**
 * Checkout extended with consent tracking via buyer object.
 *
 * This interface was referenced by `BuyerConsentExtensionResponse`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithBuyerConsentResponse = CheckoutResponse & {
  buyer?: BuyerWithConsentResponse;
  [k: string]: unknown;
};
/**
 * Checkout extended with discount capability.
 *
 * This interface was referenced by `DiscountExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithDiscountCompleteRequest = CheckoutCompleteRequest & {
  [k: string]: unknown;
};
/**
 * Checkout extended with discount capability.
 *
 * This interface was referenced by `DiscountExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithDiscountCreateRequest = CheckoutCreateRequest & {
  discounts?: DiscountsObject;
  [k: string]: unknown;
};
/**
 * Checkout extended with discount capability.
 *
 * This interface was referenced by `DiscountExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithDiscountUpdateRequest = CheckoutUpdateRequest & {
  discounts?: DiscountsObject1;
  [k: string]: unknown;
};
/**
 * Checkout extended with discount capability.
 *
 * This interface was referenced by `DiscountExtensionResponse`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithDiscountResponse = CheckoutResponse & {
  discounts?: DiscountsObject2;
  [k: string]: unknown;
};
/**
 * A destination for fulfillment.
 */
export type FulfillmentDestinationRequest = ShippingDestinationRequest | RetailLocationRequest;
/**
 * Shipping destination.
 */
export type ShippingDestinationRequest = PostalAddress & {
  /**
   * ID specific to this shipping destination.
   */
  id?: string;
  [k: string]: unknown;
};
/**
 * Checkout extended with hierarchical fulfillment.
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithFulfillmentCompleteRequest = CheckoutCompleteRequest & {
  [k: string]: unknown;
};
/**
 * Checkout extended with hierarchical fulfillment.
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithFulfillmentCreateRequest = CheckoutCreateRequest & {
  fulfillment?: FulfillmentRequest;
  [k: string]: unknown;
};
/**
 * Checkout extended with hierarchical fulfillment.
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithFulfillmentUpdateRequest = CheckoutUpdateRequest & {
  fulfillment?: FulfillmentRequest;
  [k: string]: unknown;
};
/**
 * A destination for fulfillment.
 */
export type FulfillmentDestinationResponse = ShippingDestinationResponse | RetailLocationResponse;
/**
 * Shipping destination.
 */
export type ShippingDestinationResponse = PostalAddress & {
  /**
   * ID specific to this shipping destination.
   */
  id: string;
  [k: string]: unknown;
};
/**
 * Checkout extended with hierarchical fulfillment.
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "checkout".
 */
export type CheckoutWithFulfillmentResponse = CheckoutResponse & {
  fulfillment?: FulfillmentResponse;
  [k: string]: unknown;
};

/**
 * Extends Checkout with cryptographic mandate support for non-repudiable authorization per the AP2 protocol. Uses embedded signature model with ap2 namespace.
 */
export declare interface AP2MandateExtensionCompleteRequest {
  [k: string]: unknown;
}
/**
 * AP2 extension data including merchant authorization.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "ap2_with_merchant_authorization".
 */
export declare interface Ap2WithMerchantAuthorization {
  [k: string]: unknown;
}
/**
 * AP2 extension data including checkout mandate.
 *
 * This interface was referenced by `AP2MandateExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "ap2_with_checkout_mandate".
 */
export declare interface Ap2WithCheckoutMandate {
  checkout_mandate?: CheckoutMandateCompleteRequest;
  [k: string]: unknown;
}
/**
 * Base checkout schema. Extensions compose onto this using allOf.
 */
export declare interface CheckoutCompleteRequest {
  payment: PaymentCompleteRequest;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentCompleteRequest {
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
/**
 * The base definition for any payment instrument. It links the instrument to a specific Merchant configuration (handler_id) and defines common fields like billing address.
 */
export declare interface PaymentInstrumentBase {
  /**
   * A unique identifier for this instrument instance, assigned by the Agent. Used to reference this specific instrument in the 'payment.selected_instrument_id' field.
   */
  id: string;
  /**
   * The unique identifier for the handler instance that produced this instrument. This corresponds to the 'id' field in the Payment Handler definition.
   */
  handler_id: string;
  /**
   * The broad category of the instrument (e.g., 'card', 'tokenized_card'). Specific schemas will constrain this to a constant value.
   */
  type: string;
  billing_address?: PostalAddress;
  credential?: PaymentCredential;
  [k: string]: unknown;
}
export declare interface PostalAddress {
  /**
   * An address extension such as an apartment number, C/O or alternative name.
   */
  extended_address?: string;
  /**
   * The street address.
   */
  street_address?: string;
  /**
   * The locality in which the street address is, and which is in the region. For example, Mountain View.
   */
  address_locality?: string;
  /**
   * The region in which the locality is, and which is in the country. Required for applicable countries (i.e. state in US, province in CA). For example, California or another appropriate first-level Administrative division.
   */
  address_region?: string;
  /**
   * The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for example "US". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country code such as "SGP" or a full country name such as "Singapore" can also be used.
   */
  address_country?: string;
  /**
   * The postal code. For example, 94043.
   */
  postal_code?: string;
  /**
   * Optional. First name of the contact associated with the address.
   */
  first_name?: string;
  /**
   * Optional. Last name of the contact associated with the address.
   */
  last_name?: string;
  /**
   * Optional. Full name of the contact associated with the address (if first_name or last_name fields are present they take precedence).
   */
  full_name?: string;
  /**
   * Optional. Phone number of the contact associated with the address.
   */
  phone_number?: string;
  [k: string]: unknown;
}
/**
 * Base token credential schema. Concrete payment handlers may extend this schema with additional fields and define their own constraints.
 */
export declare interface TokenCredentialResponse {
  /**
   * The specific type of token produced by the handler (e.g., 'stripe_token').
   */
  type: string;
  [k: string]: unknown;
}
/**
 * A card credential containing sensitive payment card details including raw Primary Account Numbers (PANs). This credential type MUST NOT be used for checkout, only with payment handlers that tokenize or encrypt credentials. CRITICAL: Both parties handling CardCredential (sender and receiver) MUST be PCI DSS compliant. Transmission MUST use HTTPS/TLS with strong cipher suites.
 */
export declare interface CardCredential {
  /**
   * The credential type identifier for card credentials.
   */
  type: 'card';
  /**
   * The type of card number. Network tokens are preferred with fallback to FPAN. See PCI Scope for more details.
   */
  card_number_type: 'fpan' | 'network_token' | 'dpan';
  /**
   * Card number.
   */
  number?: string;
  /**
   * The month of the card's expiration date (1-12).
   */
  expiry_month?: number;
  /**
   * The year of the card's expiration date.
   */
  expiry_year?: number;
  /**
   * Cardholder name.
   */
  name?: string;
  /**
   * Card CVC number.
   */
  cvc?: string;
  /**
   * Cryptogram provided with network tokens.
   */
  cryptogram?: string;
  /**
   * Electronic Commerce Indicator / Security Level Indicator provided with network tokens.
   */
  eci_value?: string;
  [k: string]: unknown;
}
/**
 * Extends Checkout with cryptographic mandate support for non-repudiable authorization per the AP2 protocol. Uses embedded signature model with ap2 namespace.
 */
export declare interface AP2MandateExtensionCreateRequest {
  [k: string]: unknown;
}
/**
 * Base checkout schema. Extensions compose onto this using allOf.
 */
export declare interface CheckoutCreateRequest {
  /**
   * List of line items being checked out.
   */
  line_items: LineItemCreateRequest[];
  buyer?: Buyer;
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  payment?: PaymentCreateRequest;
  [k: string]: unknown;
}
/**
 * Line item object. Expected to use the currency of the parent object.
 */
export declare interface LineItemCreateRequest {
  item: ItemCreateRequest;
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  [k: string]: unknown;
}
export declare interface ItemCreateRequest {
  /**
   * Should be recognized by both the Platform, and the Business. For Google it should match the id provided in the "id" field in the product feed.
   */
  id: string;
  [k: string]: unknown;
}
export declare interface Buyer {
  /**
   * First name of the buyer.
   */
  first_name?: string;
  /**
   * Last name of the buyer.
   */
  last_name?: string;
  /**
   * Optional, buyer's full name (if first_name or last_name fields are present they take precedence).
   */
  full_name?: string;
  /**
   * Email of the buyer.
   */
  email?: string;
  /**
   * E.164 standard.
   */
  phone_number?: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentCreateRequest {
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with cryptographic mandate support for non-repudiable authorization per the AP2 protocol. Uses embedded signature model with ap2 namespace.
 */
export declare interface AP2MandateExtensionUpdateRequest {
  [k: string]: unknown;
}
/**
 * Base checkout schema. Extensions compose onto this using allOf.
 */
export declare interface CheckoutUpdateRequest {
  /**
   * Unique identifier of the checkout session.
   */
  id: string;
  /**
   * List of line items being checked out.
   */
  line_items: LineItemUpdateRequest[];
  buyer?: Buyer;
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  payment?: PaymentUpdateRequest;
  [k: string]: unknown;
}
/**
 * Line item object. Expected to use the currency of the parent object.
 */
export declare interface LineItemUpdateRequest {
  id?: string;
  item: ItemUpdateRequest;
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
export declare interface ItemUpdateRequest {
  /**
   * Should be recognized by both the Platform, and the Business. For Google it should match the id provided in the "id" field in the product feed.
   */
  id: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentUpdateRequest {
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with cryptographic mandate support for non-repudiable authorization per the AP2 protocol. Uses embedded signature model with ap2 namespace.
 */
export declare interface AP2MandateExtensionResponse {
  [k: string]: unknown;
}
/**
 * AP2 extension data including merchant authorization.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "ap2_with_merchant_authorization".
 */
export declare interface Ap2WithMerchantAuthorization1 {
  merchant_authorization?: MerchantAuthorizationResponse;
  [k: string]: unknown;
}
/**
 * AP2 extension data including checkout mandate.
 *
 * This interface was referenced by `AP2MandateExtensionResponse`'s JSON-Schema
 * via the `definition` "ap2_with_checkout_mandate".
 */
export declare interface Ap2WithCheckoutMandate1 {
  checkout_mandate?: CheckoutMandateResponse;
  [k: string]: unknown;
}
/**
 * Base checkout schema. Extensions compose onto this using allOf.
 */
export declare interface CheckoutResponse {
  ucp: UCPCheckoutResponse;
  /**
   * Unique identifier of the checkout session.
   */
  id: string;
  /**
   * List of line items being checked out.
   */
  line_items: LineItemResponse[];
  buyer?: Buyer;
  /**
   * Checkout state indicating the current phase and required action. See Checkout Status lifecycle documentation for state transition details.
   */
  status:
    | 'incomplete'
    | 'requires_escalation'
    | 'ready_for_complete'
    | 'complete_in_progress'
    | 'completed'
    | 'canceled';
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  /**
   * Different cart totals.
   */
  totals: TotalResponse[];
  /**
   * List of messages with error and info about the checkout session state.
   */
  messages?: Message[];
  /**
   * Links to be displayed by the platform (Privacy Policy, TOS). Mandatory for legal compliance.
   */
  links: Link[];
  /**
   * RFC 3339 expiry timestamp. Default TTL is 6 hours from creation if not sent.
   */
  expires_at?: string;
  /**
   * URL for checkout handoff and session recovery. MUST be provided when status is requires_escalation. See specification for format and availability requirements.
   */
  continue_url?: string;
  payment: PaymentResponse;
  order?: OrderConfirmation;
  [k: string]: unknown;
}
/**
 * UCP metadata for checkout responses.
 */
export declare interface UCPCheckoutResponse {
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version: string;
  /**
   * Active capabilities for this response.
   */
  capabilities: CapabilityResponse[];
  [k: string]: unknown;
}
export declare interface Base {
  /**
   * Stable capability identifier in reverse-domain notation (e.g., dev.ucp.shopping.checkout). Used in capability negotiation.
   */
  name?: string;
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version?: string;
  /**
   * URL to human-readable specification document.
   */
  spec?: string;
  /**
   * URL to JSON Schema for this capability's payload.
   */
  schema?: string;
  /**
   * Parent capability this extends. Present for extensions, absent for root capabilities.
   */
  extends?: string;
  /**
   * Capability-specific configuration (structure defined by each capability).
   */
  config?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Line item object. Expected to use the currency of the parent object.
 */
export declare interface LineItemResponse {
  id: string;
  item: ItemResponse;
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  /**
   * Line item totals breakdown.
   */
  totals: TotalResponse[];
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
export declare interface ItemResponse {
  /**
   * Should be recognized by both the Platform, and the Business. For Google it should match the id provided in the "id" field in the product feed.
   */
  id: string;
  /**
   * Product title.
   */
  title: string;
  /**
   * Unit price in minor (cents) currency units.
   */
  price: number;
  /**
   * Product image URI.
   */
  image_url?: string;
  [k: string]: unknown;
}
export declare interface TotalResponse {
  /**
   * Type of total categorization.
   */
  type: 'items_discount' | 'subtotal' | 'discount' | 'fulfillment' | 'tax' | 'fee' | 'total';
  /**
   * Text to display against the amount. Should reflect appropriate method (e.g., 'Shipping', 'Delivery').
   */
  display_text?: string;
  /**
   * If type == total, sums subtotal - discount + fulfillment + tax + fee. Should be >= 0. Amount in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
export declare interface MessageError {
  /**
   * Message type discriminator.
   */
  type: 'error';
  /**
   * Error code. Possible values include: missing, invalid, out_of_stock, payment_declined, requires_sign_in, requires_3ds, requires_identity_linking. Freeform codes also allowed.
   */
  code: string;
  /**
   * RFC 9535 JSONPath to the component the message refers to (e.g., $.items[1]).
   */
  path?: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  /**
   * Human-readable message.
   */
  content: string;
  /**
   * Declares who resolves this error. 'recoverable': agent can fix via API. 'requires_buyer_input': merchant requires information their API doesn't support collecting programmatically (checkout incomplete). 'requires_buyer_review': buyer must authorize before order placement due to policy, regulatory, or entitlement rules (checkout complete). Errors with 'requires_*' severity contribute to 'status: requires_escalation'.
   */
  severity: 'recoverable' | 'requires_buyer_input' | 'requires_buyer_review';
  [k: string]: unknown;
}
export declare interface MessageWarning {
  /**
   * Message type discriminator.
   */
  type: 'warning';
  /**
   * JSONPath (RFC 9535) to related field (e.g., $.line_items[0]).
   */
  path?: string;
  /**
   * Warning code. Machine-readable identifier for the warning type (e.g., final_sale, prop65, fulfillment_changed, age_restricted, etc.).
   */
  code: string;
  /**
   * Human-readable warning message that MUST be displayed.
   */
  content: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  [k: string]: unknown;
}
export declare interface MessageInfo {
  /**
   * Message type discriminator.
   */
  type: 'info';
  /**
   * RFC 9535 JSONPath to the component the message refers to.
   */
  path?: string;
  /**
   * Info code for programmatic handling.
   */
  code?: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  /**
   * Human-readable message.
   */
  content: string;
  [k: string]: unknown;
}
export declare interface Link {
  /**
   * Type of link. Well-known values: `privacy_policy`, `terms_of_service`, `refund_policy`, `shipping_policy`, `faq`. Consumers SHOULD handle unknown values gracefully by displaying them using the `title` field or omitting the link.
   */
  type: string;
  /**
   * The actual URL pointing to the content to be displayed.
   */
  url: string;
  /**
   * Optional display text for the link. When provided, use this instead of generating from type.
   */
  title?: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentResponse {
  /**
   * Processing configurations that define how payment instruments can be collected. Each handler specifies a tokenization or payment collection strategy.
   */
  handlers: PaymentHandlerResponse[];
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
export declare interface PaymentHandlerResponse {
  /**
   * The unique identifier for this handler instance within the payment.handlers. Used by payment instruments to reference which handler produced them.
   */
  id: string;
  /**
   * The specification name using reverse-DNS format. For example, dev.ucp.delegate_payment.
   */
  name: string;
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version: string;
  /**
   * A URI pointing to the technical specification or schema that defines how this handler operates.
   */
  spec: string;
  /**
   * A URI pointing to a JSON Schema used to validate the structure of the config object.
   */
  config_schema: string;
  instrument_schemas: string[];
  /**
   * A dictionary containing provider-specific configuration details, such as merchant IDs, supported networks, or gateway credentials.
   */
  config: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Order details available at the time of checkout completion.
 */
export declare interface OrderConfirmation {
  /**
   * Unique order identifier.
   */
  id: string;
  /**
   * Permalink to access the order on merchant site.
   */
  permalink_url: string;
  [k: string]: unknown;
}
/**
 * Extends Checkout with buyer consent tracking for privacy compliance via the buyer object.
 */
export declare interface BuyerConsentExtensionCompleteRequest {
  [k: string]: unknown;
}
/**
 * User consent states for data processing
 *
 * This interface was referenced by `BuyerConsentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "consent".
 */
export declare interface Consent {
  /**
   * Consent for analytics and performance tracking.
   */
  analytics?: boolean;
  /**
   * Consent for storing user preferences.
   */
  preferences?: boolean;
  /**
   * Consent for marketing communications.
   */
  marketing?: boolean;
  /**
   * Consent for selling data to third parties (CCPA).
   */
  sale_of_data?: boolean;
  [k: string]: unknown;
}
/**
 * Extends Checkout with buyer consent tracking for privacy compliance via the buyer object.
 */
export declare interface BuyerConsentExtensionCreateRequest {
  [k: string]: unknown;
}
/**
 * User consent states for data processing
 *
 * This interface was referenced by `BuyerConsentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "consent".
 */
export declare interface Consent1 {
  /**
   * Consent for analytics and performance tracking.
   */
  analytics?: boolean;
  /**
   * Consent for storing user preferences.
   */
  preferences?: boolean;
  /**
   * Consent for marketing communications.
   */
  marketing?: boolean;
  /**
   * Consent for selling data to third parties (CCPA).
   */
  sale_of_data?: boolean;
  [k: string]: unknown;
}
/**
 * Extends Checkout with buyer consent tracking for privacy compliance via the buyer object.
 */
export declare interface BuyerConsentExtensionUpdateRequest {
  [k: string]: unknown;
}
/**
 * User consent states for data processing
 *
 * This interface was referenced by `BuyerConsentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "consent".
 */
export declare interface Consent2 {
  /**
   * Consent for analytics and performance tracking.
   */
  analytics?: boolean;
  /**
   * Consent for storing user preferences.
   */
  preferences?: boolean;
  /**
   * Consent for marketing communications.
   */
  marketing?: boolean;
  /**
   * Consent for selling data to third parties (CCPA).
   */
  sale_of_data?: boolean;
  [k: string]: unknown;
}
/**
 * Extends Checkout with buyer consent tracking for privacy compliance via the buyer object.
 */
export declare interface BuyerConsentExtensionResponse {
  [k: string]: unknown;
}
/**
 * User consent states for data processing
 *
 * This interface was referenced by `BuyerConsentExtensionResponse`'s JSON-Schema
 * via the `definition` "consent".
 */
export declare interface Consent3 {
  /**
   * Consent for analytics and performance tracking.
   */
  analytics?: boolean;
  /**
   * Consent for storing user preferences.
   */
  preferences?: boolean;
  /**
   * Consent for marketing communications.
   */
  marketing?: boolean;
  /**
   * Consent for selling data to third parties (CCPA).
   */
  sale_of_data?: boolean;
  [k: string]: unknown;
}
/**
 * Extends Checkout with discount code support, enabling agents to apply promotional, loyalty, referral, and other discount codes.
 */
export declare interface DiscountExtensionCompleteRequest {
  [k: string]: unknown;
}
/**
 * Breakdown of how a discount amount was allocated to a specific target.
 *
 * This interface was referenced by `DiscountExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "allocation".
 */
export declare interface Allocation {
  /**
   * JSONPath to the allocation target (e.g., '$.line_items[0]', '$.totals.shipping').
   */
  path: string;
  /**
   * Amount allocated to this target in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
/**
 * A discount that was successfully applied.
 *
 * This interface was referenced by `DiscountExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "applied_discount".
 */
export declare interface AppliedDiscount {
  /**
   * The discount code. Omitted for automatic discounts.
   */
  code?: string;
  /**
   * Human-readable discount name (e.g., 'Summer Sale 20% Off').
   */
  title: string;
  /**
   * Total discount amount in minor (cents) currency units.
   */
  amount: number;
  /**
   * True if applied automatically by merchant rules (no code required).
   */
  automatic?: boolean;
  /**
   * Allocation method. 'each' = applied independently per item. 'across' = split proportionally by value.
   */
  method?: 'each' | 'across';
  /**
   * Stacking order for discount calculation. Lower numbers applied first (1 = first).
   */
  priority?: number;
  /**
   * Breakdown of where this discount was allocated. Sum of allocation amounts equals total amount.
   */
  allocations?: Allocation[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with discount code support, enabling agents to apply promotional, loyalty, referral, and other discount codes.
 */
export declare interface DiscountExtensionCreateRequest {
  [k: string]: unknown;
}
/**
 * Breakdown of how a discount amount was allocated to a specific target.
 *
 * This interface was referenced by `DiscountExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "allocation".
 */
export declare interface Allocation1 {
  /**
   * JSONPath to the allocation target (e.g., '$.line_items[0]', '$.totals.shipping').
   */
  path: string;
  /**
   * Amount allocated to this target in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
/**
 * A discount that was successfully applied.
 *
 * This interface was referenced by `DiscountExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "applied_discount".
 */
export declare interface AppliedDiscount1 {
  /**
   * The discount code. Omitted for automatic discounts.
   */
  code?: string;
  /**
   * Human-readable discount name (e.g., 'Summer Sale 20% Off').
   */
  title: string;
  /**
   * Total discount amount in minor (cents) currency units.
   */
  amount: number;
  /**
   * True if applied automatically by merchant rules (no code required).
   */
  automatic?: boolean;
  /**
   * Allocation method. 'each' = applied independently per item. 'across' = split proportionally by value.
   */
  method?: 'each' | 'across';
  /**
   * Stacking order for discount calculation. Lower numbers applied first (1 = first).
   */
  priority?: number;
  /**
   * Breakdown of where this discount was allocated. Sum of allocation amounts equals total amount.
   */
  allocations?: Allocation1[];
  [k: string]: unknown;
}
/**
 * Discount codes input and applied discounts output.
 *
 * This interface was referenced by `DiscountExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "discounts_object".
 */
export declare interface DiscountsObject {
  /**
   * Discount codes to apply. Case-insensitive. Replaces previously submitted codes. Send empty array to clear.
   */
  codes?: string[];
  /**
   * Discounts successfully applied (code-based and automatic).
   */
  applied?: AppliedDiscount1[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with discount code support, enabling agents to apply promotional, loyalty, referral, and other discount codes.
 */
export declare interface DiscountExtensionUpdateRequest {
  [k: string]: unknown;
}
/**
 * Breakdown of how a discount amount was allocated to a specific target.
 *
 * This interface was referenced by `DiscountExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "allocation".
 */
export declare interface Allocation2 {
  /**
   * JSONPath to the allocation target (e.g., '$.line_items[0]', '$.totals.shipping').
   */
  path: string;
  /**
   * Amount allocated to this target in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
/**
 * A discount that was successfully applied.
 *
 * This interface was referenced by `DiscountExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "applied_discount".
 */
export declare interface AppliedDiscount2 {
  /**
   * The discount code. Omitted for automatic discounts.
   */
  code?: string;
  /**
   * Human-readable discount name (e.g., 'Summer Sale 20% Off').
   */
  title: string;
  /**
   * Total discount amount in minor (cents) currency units.
   */
  amount: number;
  /**
   * True if applied automatically by merchant rules (no code required).
   */
  automatic?: boolean;
  /**
   * Allocation method. 'each' = applied independently per item. 'across' = split proportionally by value.
   */
  method?: 'each' | 'across';
  /**
   * Stacking order for discount calculation. Lower numbers applied first (1 = first).
   */
  priority?: number;
  /**
   * Breakdown of where this discount was allocated. Sum of allocation amounts equals total amount.
   */
  allocations?: Allocation2[];
  [k: string]: unknown;
}
/**
 * Discount codes input and applied discounts output.
 *
 * This interface was referenced by `DiscountExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "discounts_object".
 */
export declare interface DiscountsObject1 {
  /**
   * Discount codes to apply. Case-insensitive. Replaces previously submitted codes. Send empty array to clear.
   */
  codes?: string[];
  /**
   * Discounts successfully applied (code-based and automatic).
   */
  applied?: AppliedDiscount2[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with discount code support, enabling agents to apply promotional, loyalty, referral, and other discount codes.
 */
export declare interface DiscountExtensionResponse {
  [k: string]: unknown;
}
/**
 * Breakdown of how a discount amount was allocated to a specific target.
 *
 * This interface was referenced by `DiscountExtensionResponse`'s JSON-Schema
 * via the `definition` "allocation".
 */
export declare interface Allocation3 {
  /**
   * JSONPath to the allocation target (e.g., '$.line_items[0]', '$.totals.shipping').
   */
  path: string;
  /**
   * Amount allocated to this target in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
/**
 * A discount that was successfully applied.
 *
 * This interface was referenced by `DiscountExtensionResponse`'s JSON-Schema
 * via the `definition` "applied_discount".
 */
export declare interface AppliedDiscount3 {
  /**
   * The discount code. Omitted for automatic discounts.
   */
  code?: string;
  /**
   * Human-readable discount name (e.g., 'Summer Sale 20% Off').
   */
  title: string;
  /**
   * Total discount amount in minor (cents) currency units.
   */
  amount: number;
  /**
   * True if applied automatically by merchant rules (no code required).
   */
  automatic?: boolean;
  /**
   * Allocation method. 'each' = applied independently per item. 'across' = split proportionally by value.
   */
  method?: 'each' | 'across';
  /**
   * Stacking order for discount calculation. Lower numbers applied first (1 = first).
   */
  priority?: number;
  /**
   * Breakdown of where this discount was allocated. Sum of allocation amounts equals total amount.
   */
  allocations?: Allocation3[];
  [k: string]: unknown;
}
/**
 * Discount codes input and applied discounts output.
 *
 * This interface was referenced by `DiscountExtensionResponse`'s JSON-Schema
 * via the `definition` "discounts_object".
 */
export declare interface DiscountsObject2 {
  /**
   * Discount codes to apply. Case-insensitive. Replaces previously submitted codes. Send empty array to clear.
   */
  codes?: string[];
  /**
   * Discounts successfully applied (code-based and automatic).
   */
  applied?: AppliedDiscount3[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with fulfillment support using methods, destinations, and groups.
 */
export declare interface FulfillmentExtensionCompleteRequest {
  [k: string]: unknown;
}
/**
 * A fulfillment option within a group (e.g., Standard Shipping $5, Express $15).
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "fulfillment_option".
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_option".
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_option".
 */
export declare interface FulfillmentOptionRequest {
  [k: string]: unknown;
}
/**
 * A merchant-generated package/group of line items with fulfillment options.
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "fulfillment_group".
 */
export declare interface FulfillmentGroupCompleteRequest {
  /**
   * Group identifier for referencing merchant-generated groups in updates.
   */
  id: string;
  /**
   * ID of the selected fulfillment option for this group.
   */
  selected_option_id?: string | null;
  [k: string]: unknown;
}
/**
 * A fulfillment method (shipping or pickup) with destinations and groups.
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "fulfillment_method".
 */
export declare interface FulfillmentMethodCompleteRequest {
  /**
   * Unique fulfillment method identifier.
   */
  id: string;
  /**
   * Fulfillment method type.
   */
  type: 'shipping' | 'pickup';
  /**
   * Line item IDs fulfilled via this method.
   */
  line_item_ids: string[];
  /**
   * Available destinations. For shipping: addresses. For pickup: retail locations.
   */
  destinations?: FulfillmentDestinationRequest[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Fulfillment groups for selecting options. Agent sets selected_option_id on groups to choose shipping method.
   */
  groups?: FulfillmentGroupCompleteRequest[];
  [k: string]: unknown;
}
/**
 * A pickup location (retail store, locker, etc.).
 */
export declare interface RetailLocationRequest {
  /**
   * Location name (e.g., store name).
   */
  name: string;
  address?: PostalAddress;
  [k: string]: unknown;
}
/**
 * Inventory availability hint for a fulfillment method type.
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "fulfillment_available_method".
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_available_method".
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_available_method".
 */
export declare interface FulfillmentAvailableMethodRequest {
  [k: string]: unknown;
}
/**
 * Container for fulfillment methods and availability.
 *
 * This interface was referenced by `FulfillmentExtensionCompleteRequest`'s JSON-Schema
 * via the `definition` "fulfillment".
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "fulfillment".
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "fulfillment".
 */
export declare interface FulfillmentRequest {
  /**
   * Fulfillment methods for cart items.
   */
  methods?: FulfillmentMethodCreateRequest[];
  [k: string]: unknown;
}
/**
 * A fulfillment method (shipping or pickup) with destinations and groups.
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_method".
 */
export declare interface FulfillmentMethodCreateRequest {
  /**
   * Fulfillment method type.
   */
  type: 'shipping' | 'pickup';
  /**
   * Line item IDs fulfilled via this method.
   */
  line_item_ids?: string[];
  /**
   * Available destinations. For shipping: addresses. For pickup: retail locations.
   */
  destinations?: FulfillmentDestinationRequest[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Fulfillment groups for selecting options. Agent sets selected_option_id on groups to choose shipping method.
   */
  groups?: FulfillmentGroupCreateRequest[];
  [k: string]: unknown;
}
/**
 * A merchant-generated package/group of line items with fulfillment options.
 *
 * This interface was referenced by `FulfillmentExtensionCreateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_group".
 */
export declare interface FulfillmentGroupCreateRequest {
  /**
   * ID of the selected fulfillment option for this group.
   */
  selected_option_id?: string | null;
  [k: string]: unknown;
}
/**
 * Extends Checkout with fulfillment support using methods, destinations, and groups.
 */
export declare interface FulfillmentExtensionCreateRequest {
  [k: string]: unknown;
}
/**
 * Extends Checkout with fulfillment support using methods, destinations, and groups.
 */
export declare interface FulfillmentExtensionUpdateRequest {
  [k: string]: unknown;
}
/**
 * A merchant-generated package/group of line items with fulfillment options.
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_group".
 */
export declare interface FulfillmentGroupUpdateRequest {
  /**
   * Group identifier for referencing merchant-generated groups in updates.
   */
  id: string;
  /**
   * ID of the selected fulfillment option for this group.
   */
  selected_option_id?: string | null;
  [k: string]: unknown;
}
/**
 * A fulfillment method (shipping or pickup) with destinations and groups.
 *
 * This interface was referenced by `FulfillmentExtensionUpdateRequest`'s JSON-Schema
 * via the `definition` "fulfillment_method".
 */
export declare interface FulfillmentMethodUpdateRequest {
  /**
   * Unique fulfillment method identifier.
   */
  id: string;
  /**
   * Line item IDs fulfilled via this method.
   */
  line_item_ids: string[];
  /**
   * Available destinations. For shipping: addresses. For pickup: retail locations.
   */
  destinations?: FulfillmentDestinationRequest[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Fulfillment groups for selecting options. Agent sets selected_option_id on groups to choose shipping method.
   */
  groups?: FulfillmentGroupUpdateRequest[];
  [k: string]: unknown;
}
/**
 * Extends Checkout with fulfillment support using methods, destinations, and groups.
 */
export declare interface FulfillmentExtensionResponse {
  [k: string]: unknown;
}
/**
 * A fulfillment option within a group (e.g., Standard Shipping $5, Express $15).
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "fulfillment_option".
 */
export declare interface FulfillmentOptionResponse {
  /**
   * Unique fulfillment option identifier.
   */
  id: string;
  /**
   * Short label (e.g., 'Express Shipping', 'Curbside Pickup').
   */
  title: string;
  /**
   * Complete context for buyer decision (e.g., 'Arrives Dec 12-15 via FedEx').
   */
  description?: string;
  /**
   * Carrier name (for shipping).
   */
  carrier?: string;
  /**
   * Earliest fulfillment date.
   */
  earliest_fulfillment_time?: string;
  /**
   * Latest fulfillment date.
   */
  latest_fulfillment_time?: string;
  /**
   * Fulfillment option totals breakdown.
   */
  totals: TotalResponse[];
  [k: string]: unknown;
}
/**
 * A merchant-generated package/group of line items with fulfillment options.
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "fulfillment_group".
 */
export declare interface FulfillmentGroupResponse {
  /**
   * Group identifier for referencing merchant-generated groups in updates.
   */
  id: string;
  /**
   * Line item IDs included in this group/package.
   */
  line_item_ids: string[];
  /**
   * Available fulfillment options for this group.
   */
  options?: FulfillmentOptionResponse[];
  /**
   * ID of the selected fulfillment option for this group.
   */
  selected_option_id?: string | null;
  [k: string]: unknown;
}
/**
 * A fulfillment method (shipping or pickup) with destinations and groups.
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "fulfillment_method".
 */
export declare interface FulfillmentMethodResponse {
  /**
   * Unique fulfillment method identifier.
   */
  id: string;
  /**
   * Fulfillment method type.
   */
  type: 'shipping' | 'pickup';
  /**
   * Line item IDs fulfilled via this method.
   */
  line_item_ids: string[];
  /**
   * Available destinations. For shipping: addresses. For pickup: retail locations.
   */
  destinations?: FulfillmentDestinationResponse[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Fulfillment groups for selecting options. Agent sets selected_option_id on groups to choose shipping method.
   */
  groups?: FulfillmentGroupResponse[];
  [k: string]: unknown;
}
/**
 * A pickup location (retail store, locker, etc.).
 */
export declare interface RetailLocationResponse {
  /**
   * Unique location identifier.
   */
  id: string;
  /**
   * Location name (e.g., store name).
   */
  name: string;
  address?: PostalAddress;
  [k: string]: unknown;
}
/**
 * Inventory availability hint for a fulfillment method type.
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "fulfillment_available_method".
 */
export declare interface FulfillmentAvailableMethodResponse {
  /**
   * Fulfillment method type this availability applies to.
   */
  type: 'shipping' | 'pickup';
  /**
   * Line items available for this fulfillment method.
   */
  line_item_ids: string[];
  /**
   * 'now' for immediate availability, or ISO 8601 date for future (preorders, transfers).
   */
  fulfillable_on?: string | null;
  /**
   * Human-readable availability info (e.g., 'Available for pickup at Downtown Store today').
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Container for fulfillment methods and availability.
 *
 * This interface was referenced by `FulfillmentExtensionResponse`'s JSON-Schema
 * via the `definition` "fulfillment".
 */
export declare interface FulfillmentResponse {
  /**
   * Fulfillment methods for cart items.
   */
  methods?: FulfillmentMethodResponse[];
  /**
   * Inventory availability hints.
   */
  available_methods?: FulfillmentAvailableMethodResponse[];
  [k: string]: unknown;
}
/**
 * Order schema with immutable line items, buyer-facing fulfillment expectations, and append-only event logs.
 */
export declare interface Order {
  ucp: UCPOrderResponse;
  /**
   * Unique order identifier.
   */
  id: string;
  /**
   * Associated checkout ID for reconciliation.
   */
  checkout_id: string;
  /**
   * Permalink to access the order on merchant site.
   */
  permalink_url: string;
  /**
   * Immutable line items  source of truth for what was ordered.
   */
  line_items: OrderLineItem[];
  /**
   * Fulfillment data: buyer expectations and what actually happened.
   */
  fulfillment: {
    /**
     * Buyer-facing groups representing when/how items will be delivered. Can be split, merged, or adjusted post-order.
     */
    expectations?: Expectation[];
    /**
     * Append-only event log of actual shipments. Each event references line items by ID.
     */
    events?: FulfillmentEvent[];
    [k: string]: unknown;
  };
  /**
   * Append-only event log of money movements (refunds, returns, credits, disputes, cancellations, etc.) that exist independently of fulfillment.
   */
  adjustments?: Adjustment[];
  /**
   * Different totals for the order.
   */
  totals: TotalResponse[];
  [k: string]: unknown;
}
/**
 * UCP metadata for order responses. No payment handlers needed post-purchase.
 */
export declare interface UCPOrderResponse {
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version: string;
  /**
   * Active capabilities for this response.
   */
  capabilities: CapabilityResponse[];
  [k: string]: unknown;
}
export declare interface OrderLineItem {
  /**
   * Line item identifier.
   */
  id: string;
  item: ItemResponse;
  /**
   * Quantity tracking. Both total and fulfilled are derived from events.
   */
  quantity: {
    /**
     * Current total quantity.
     */
    total: number;
    /**
     * Quantity fulfilled (sum from fulfillment events).
     */
    fulfilled: number;
    [k: string]: unknown;
  };
  /**
   * Line item totals breakdown.
   */
  totals: TotalResponse[];
  /**
   * Derived status: fulfilled if quantity.fulfilled == quantity.total, partial if quantity.fulfilled > 0, otherwise processing.
   */
  status: 'processing' | 'partial' | 'fulfilled';
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
/**
 * Buyer-facing fulfillment expectation representing logical groupings of items (e.g., 'package'). Can be split, merged, or adjusted post-order to set buyer expectations for when/how items arrive.
 */
export declare interface Expectation {
  /**
   * Expectation identifier.
   */
  id: string;
  /**
   * Which line items and quantities are in this expectation.
   */
  line_items: Array<{
    /**
     * Line item ID reference.
     */
    id: string;
    /**
     * Quantity of this item in this expectation.
     */
    quantity: number;
    [k: string]: unknown;
  }>;
  /**
   * Delivery method type (shipping, pickup, digital).
   */
  method_type: 'shipping' | 'pickup' | 'digital';
  destination: PostalAddress;
  /**
   * Human-readable delivery description (e.g., 'Arrives in 5-8 business days').
   */
  description?: string;
  /**
   * When this expectation can be fulfilled: 'now' or ISO 8601 timestamp for future date (backorder, pre-order).
   */
  fulfillable_on?: string;
  [k: string]: unknown;
}
/**
 * Append-only fulfillment event representing an actual shipment. References line items by ID.
 */
export declare interface FulfillmentEvent {
  /**
   * Fulfillment event identifier.
   */
  id: string;
  /**
   * RFC 3339 timestamp when this fulfillment event occurred.
   */
  occurred_at: string;
  /**
   * Fulfillment event type. Common values include: processing (preparing to ship), shipped (handed to carrier), in_transit (in delivery network), delivered (received by buyer), failed_attempt (delivery attempt failed), canceled (fulfillment canceled), undeliverable (cannot be delivered), returned_to_sender (returned to merchant).
   */
  type: string;
  /**
   * Which line items and quantities are fulfilled in this event.
   */
  line_items: Array<{
    /**
     * Line item ID reference.
     */
    id: string;
    /**
     * Quantity fulfilled in this event.
     */
    quantity: number;
    [k: string]: unknown;
  }>;
  /**
   * Carrier tracking number (required if type != processing).
   */
  tracking_number?: string;
  /**
   * URL to track this shipment (required if type != processing).
   */
  tracking_url?: string;
  /**
   * Carrier name (e.g., 'FedEx', 'USPS').
   */
  carrier?: string;
  /**
   * Human-readable description of the shipment status or delivery information (e.g., 'Delivered to front door', 'Out for delivery').
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Append-only event that exists independently of fulfillment. Typically represents money movements but can be any post-order change. Polymorphic type that can optionally reference line items.
 */
export declare interface Adjustment {
  /**
   * Adjustment event identifier.
   */
  id: string;
  /**
   * Type of adjustment (open string). Typically money-related like: refund, return, credit, price_adjustment, dispute, cancellation. Can be any value that makes sense for the merchant's business.
   */
  type: string;
  /**
   * RFC 3339 timestamp when this adjustment occurred.
   */
  occurred_at: string;
  /**
   * Adjustment status.
   */
  status: 'pending' | 'completed' | 'failed';
  /**
   * Which line items and quantities are affected (optional).
   */
  line_items?: Array<{
    /**
     * Line item ID reference.
     */
    id: string;
    /**
     * Quantity affected by this adjustment.
     */
    quantity: number;
    [k: string]: unknown;
  }>;
  /**
   * Amount in minor units (cents) for refunds, credits, price adjustments (optional).
   */
  amount?: number;
  /**
   * Human-readable reason or description (e.g., 'Defective item', 'Customer requested').
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Platform's order capability configuration.
 *
 * This interface was referenced by `Order`'s JSON-Schema
 * via the `definition` "platform_config".
 */
export declare interface PlatformOrderConfig {
  /**
   * URL where merchant sends order lifecycle events (webhooks).
   */
  webhook_url: string;
  [k: string]: unknown;
}